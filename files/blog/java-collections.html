<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java Collections Framework - Developer Blog</title>
    <link rel="stylesheet" href="../styles.css">
</head>
<body>
    <nav class="navbar">
        <div class="container">
            <div class="nav-brand">
                <h2>DEV BLOG</h2>
            </div>
            <ul class="nav-menu">
                <li><a href="../index.html">Trang ch·ªß</a></li>
                <li><a href="../about.html">Gi·ªõi thi·ªáu</a></li>
            </ul>
        </div>
    </nav>

    <section class="article-hero">
        <div class="container">
            <div class="article-header">
                <span class="blog-category">Java</span>
                <h1>Java Collections Framework</h1>
                <div class="article-meta">
                    <span>üìÖ 24/10/2025</span>
                    <span>‚è±Ô∏è 15 ph√∫t ƒë·ªçc</span>
                </div>
            </div>
        </div>
    </section>

    <section class="article-content">
        <div class="container">
            <article class="article-body">
                <h2>Collections Framework l√† g√¨?</h2>
                <p>
                    Java Collections Framework l√† m·ªôt ki·∫øn tr√∫c th·ªëng nh·∫•t ƒë·ªÉ l∆∞u tr·ªØ v√† thao t√°c v·ªõi 
                    nh√≥m c√°c objects. N√≥ cung c·∫•p c√°c interfaces (Set, List, Queue, Map) v√† implementations 
                    (ArrayList, HashSet, HashMap, LinkedList...) ƒë·ªÉ l√†m vi·ªác v·ªõi d·ªØ li·ªáu m·ªôt c√°ch hi·ªáu qu·∫£.
                </p>

                <h2>Hierarchy c·ªßa Collections Framework</h2>
                <p>Collections Framework ƒë∆∞·ª£c t·ªï ch·ª©c theo c·∫•u tr√∫c ph√¢n c·∫•p r√µ r√†ng:</p>
                <ul>
                    <li><strong>Collection Interface:</strong> Root interface c·ªßa h·∫ßu h·∫øt collections</li>
                    <li><strong>List:</strong> Ordered collection, cho ph√©p duplicate elements</li>
                    <li><strong>Set:</strong> Collection kh√¥ng cho ph√©p duplicate elements</li>
                    <li><strong>Queue:</strong> Collection ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ hold elements tr∆∞·ªõc khi processing</li>
                    <li><strong>Map:</strong> Key-value pairs, kh√¥ng ph·∫£i l√† true collection nh∆∞ng l√† part of framework</li>
                </ul>

                <h2>1. List Interface</h2>
                <p>
                    List l√† ordered collection (sequence) cho ph√©p duplicate elements. Elements c√≥ th·ªÉ 
                    ƒë∆∞·ª£c access b·∫±ng index.
                </p>

                <h3>ArrayList</h3>
                <p>
                    ArrayList s·ª≠ d·ª•ng dynamic array ƒë·ªÉ l∆∞u tr·ªØ elements. N√≥ t·ªët cho random access 
                    nh∆∞ng ch·∫≠m khi insert/delete ·ªü gi·ªØa list.
                </p>
                <pre><code>import java.util.ArrayList;
import java.util.List;

List&lt;String&gt; fruits = new ArrayList&lt;&gt;();
fruits.add("Apple");
fruits.add("Banana");
fruits.add("Orange");
fruits.add("Apple"); // Duplicate ƒë∆∞·ª£c ph√©p

System.out.println(fruits.get(0)); // Apple
System.out.println(fruits.size()); // 4

// Iteration
for (String fruit : fruits) {
    System.out.println(fruit);
}

// Remove
fruits.remove("Banana");
fruits.remove(0); // Remove by index</code></pre>

                <h3>LinkedList</h3>
                <p>
                    LinkedList s·ª≠ d·ª•ng doubly linked list. T·ªët cho frequent insertions/deletions 
                    nh∆∞ng ch·∫≠m h∆°n ArrayList cho random access.
                </p>
                <pre><code>import java.util.LinkedList;

LinkedList&lt;Integer&gt; numbers = new LinkedList&lt;&gt;();
numbers.add(10);
numbers.addFirst(5);  // Add at beginning
numbers.addLast(20);  // Add at end
numbers.add(1, 15);   // Add at specific index

System.out.println(numbers); // [5, 15, 10, 20]</code></pre>

                <h2>2. Set Interface</h2>
                <p>
                    Set l√† collection kh√¥ng ch·ª©a duplicate elements. N√≥ modeling mathematical set abstraction.
                </p>

                <h3>HashSet</h3>
                <p>
                    HashSet s·ª≠ d·ª•ng hash table ƒë·ªÉ l∆∞u tr·ªØ. N√≥ kh√¥ng maintain order v√† c√≥ performance t·ªët 
                    cho basic operations (add, remove, contains).
                </p>
                <pre><code>import java.util.HashSet;
import java.util.Set;

Set&lt;String&gt; cities = new HashSet&lt;&gt;();
cities.add("Hanoi");
cities.add("Ho Chi Minh");
cities.add("Da Nang");
cities.add("Hanoi"); // Duplicate - s·∫Ω kh√¥ng ƒë∆∞·ª£c add

System.out.println(cities.size()); // 3
System.out.println(cities.contains("Hanoi")); // true</code></pre>

                <h3>LinkedHashSet</h3>
                <p>
                    LinkedHashSet maintain insertion order. N√≥ ch·∫≠m h∆°n HashSet m·ªôt ch√∫t nh∆∞ng preserve order.
                </p>

                <h3>TreeSet</h3>
                <p>
                    TreeSet s·ª≠ d·ª•ng tree structure v√† maintain elements theo sorted order (natural order 
                    ho·∫∑c custom Comparator).
                </p>
                <pre><code>import java.util.TreeSet;

TreeSet&lt;Integer&gt; numbers = new TreeSet&lt;&gt;();
numbers.add(50);
numbers.add(20);
numbers.add(80);
numbers.add(10);

System.out.println(numbers); // [10, 20, 50, 80] - sorted</code></pre>

                <h2>3. Queue Interface</h2>
                <p>
                    Queue ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ hold elements tr∆∞·ªõc khi processing. Th∆∞·ªùng follow FIFO 
                    (First-In-First-Out) order.
                </p>

                <h3>PriorityQueue</h3>
                <pre><code>import java.util.PriorityQueue;
import java.util.Queue;

Queue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();
pq.offer(30);
pq.offer(10);
pq.offer(20);

System.out.println(pq.poll()); // 10 - smallest element
System.out.println(pq.poll()); // 20
System.out.println(pq.peek()); // 30 - view without removing</code></pre>

                <h2>4. Map Interface</h2>
                <p>
                    Map l∆∞u tr·ªØ key-value pairs. M·ªói key l√† unique v√† map ƒë·∫øn exactly one value.
                </p>

                <h3>HashMap</h3>
                <p>
                    HashMap s·ª≠ d·ª•ng hash table. N√≥ cung c·∫•p constant-time performance cho basic operations 
                    (get, put) assuming good hash function.
                </p>
                <pre><code>import java.util.HashMap;
import java.util.Map;

Map&lt;String, Integer&gt; ages = new HashMap&lt;&gt;();
ages.put("John", 25);
ages.put("Alice", 30);
ages.put("Bob", 28);

System.out.println(ages.get("Alice")); // 30
System.out.println(ages.containsKey("John")); // true

// Iteration
for (Map.Entry&lt;String, Integer&gt; entry : ages.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}

// Get with default value (Java 8+)
int age = ages.getOrDefault("David", 0);

// Update if exists
ages.putIfAbsent("Charlie", 35);</code></pre>

                <h3>LinkedHashMap</h3>
                <p>
                    LinkedHashMap maintain insertion order c·ªßa entries.
                </p>

                <h3>TreeMap</h3>
                <p>
                    TreeMap maintain keys theo sorted order. N√≥ implement NavigableMap interface.
                </p>
                <pre><code>import java.util.TreeMap;

TreeMap&lt;String, Integer&gt; map = new TreeMap&lt;&gt;();
map.put("Charlie", 30);
map.put("Alice", 25);
map.put("Bob", 28);

System.out.println(map); // {Alice=25, Bob=28, Charlie=30} - sorted by key</code></pre>

                <h2>Collections Utility Class</h2>
                <p>
                    Java cung c·∫•p Collections utility class v·ªõi nhi·ªÅu static methods h·ªØu √≠ch:
                </p>
                <pre><code>import java.util.Collections;

List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(5, 2, 8, 1, 9));

// Sort
Collections.sort(list);
System.out.println(list); // [1, 2, 5, 8, 9]

// Reverse
Collections.reverse(list);
System.out.println(list); // [9, 8, 5, 2, 1]

// Shuffle
Collections.shuffle(list);

// Find max/min
int max = Collections.max(list);
int min = Collections.min(list);

// Binary search (list must be sorted)
Collections.sort(list);
int index = Collections.binarySearch(list, 5);

// Fill
Collections.fill(list, 0); // Fill all with 0

// Frequency
int freq = Collections.frequency(list, 5);</code></pre>

                <h2>Khi n√†o d√πng g√¨?</h2>
                
                <h3>Ch·ªçn List implementation:</h3>
                <ul>
                    <li><strong>ArrayList:</strong> Khi c·∫ßn random access nhi·ªÅu, √≠t insert/delete</li>
                    <li><strong>LinkedList:</strong> Khi c·∫ßn insert/delete nhi·ªÅu, √≠t random access</li>
                    <li><strong>Vector:</strong> Khi c·∫ßn thread-safe ArrayList (nh∆∞ng n√™n d√πng Collections.synchronizedList)</li>
                </ul>

                <h3>Ch·ªçn Set implementation:</h3>
                <ul>
                    <li><strong>HashSet:</strong> Khi kh√¥ng c·∫ßn order v√† mu·ªën performance t·ªët nh·∫•t</li>
                    <li><strong>LinkedHashSet:</strong> Khi c·∫ßn maintain insertion order</li>
                    <li><strong>TreeSet:</strong> Khi c·∫ßn elements ƒë∆∞·ª£c sorted</li>
                </ul>

                <h3>Ch·ªçn Map implementation:</h3>
                <ul>
                    <li><strong>HashMap:</strong> General purpose, best performance</li>
                    <li><strong>LinkedHashMap:</strong> Khi c·∫ßn maintain insertion order</li>
                    <li><strong>TreeMap:</strong> Khi c·∫ßn keys ƒë∆∞·ª£c sorted</li>
                    <li><strong>Hashtable:</strong> Legacy, n√™n d√πng ConcurrentHashMap thay v√¨</li>
                </ul>

                <h2>Best Practices</h2>
                <ul>
                    <li>Program to interface, not implementation (d√πng List thay v√¨ ArrayList trong declaration)</li>
                    <li>Initialize collections v·ªõi appropriate initial capacity n·∫øu bi·∫øt size</li>
                    <li>S·ª≠ d·ª•ng generics ƒë·ªÉ ensure type safety</li>
                    <li>Consider immutability - d√πng Collections.unmodifiableList() khi c·∫ßn</li>
                    <li>Implement equals() v√† hashCode() properly cho custom objects trong HashSet/HashMap</li>
                    <li>S·ª≠ d·ª•ng foreach loop ho·∫∑c streams (Java 8+) cho iteration</li>
                </ul>

                <h2>K·∫øt lu·∫≠n</h2>
                <p>
                    Java Collections Framework l√† m·ªôt trong nh·ªØng features quan tr·ªçng nh·∫•t c·ªßa Java. 
                    Hi·ªÉu r√µ c√°c interfaces v√† implementations kh√°c nhau s·∫Ω gi√∫p b·∫°n ch·ªçn ƒë√∫ng data structure 
                    cho t·ª´ng t√¨nh hu·ªëng, t·ª´ ƒë√≥ t·ªëi ∆∞u performance v√† vi·∫øt code hi·ªáu qu·∫£ h∆°n.
                </p>
                <p>
                    H√£y th·ª±c h√†nh v·ªõi c√°c collections n√†y th∆∞·ªùng xuy√™n ƒë·ªÉ th√†nh th·∫°o. Trong b√†i ti·∫øp theo, 
                    ch√∫ng ta s·∫Ω t√¨m hi·ªÉu v·ªÅ Spring Framework!
                </p>

                <a href="../index.html" class="back-link">‚Üê Quay l·∫°i trang ch·ªß</a>
            </article>
        </div>
    </section>

    <footer class="footer">
        <div class="container">
            <p>&copy; 2025 Developer Blog. All rights reserved.</p>
            <p>Made with ‚ù§Ô∏è and code</p>
        </div>
    </footer>
</body>
</html>
